extern fn println(str: string): void
extern fn printfn(str: string, val: int, val: int): void

fn concat<T>(a: [T], b: [T]): [T]
    var c = newarr(length(a) + length(b))

    for e, i in a
        c[i] = e

    for e, i in b
        c[length(a) + i] = e

    c

fn append<T>(a: [T], e: T): [T]
    concat(a, [e])

struct Pair<T, U>
    first: T
    second: U

struct Point
    x: int
    y: int

struct Location
    line: int = defline()
    column: int = 8

fn defline(): int
    println("defline!")
    4

fn singleton<T>(v: T): [T]
    [v]

fn world(dbg: string, print: bool): string
    if print
        println(dbg)
    "world"

fn iter<T>(data: [T], f: fn(int, T): void)
    fn helper(data, f, offset)
        if offset < length(data)
            f(offset, data[offset])
            helper(data, f, offset + 1)

    helper(data, f, 0)

fn dump(data: [int])
    iter(data, fn (i,x) printfn("[%d]: %d", i, x))

fn dumpp(data: [*int])
    iter(data, fn (i,x) printfn("[%d]: %d", i, *x))
    iter(data, fn (i,x) (*x) = i)

fn first<T, U>(p: Pair.<T, U>): T
    p.first

fn test(): int
    var hello = "Hello, "
    var foo = false
    if foo
        println("")
    else
        fn test(a0: string, a1: bool): string
            "inner"
        var f = fn (a0, a1) a0(a1)
        var g = f(fn(x) x, 1)
        println(worldwrap(fn (a0, a1) a0, "test", false))
        println(worldwrap(fn (a0: string, a1: bool): string "x", "test", false))
        println(worldwrap(world, "test", false))
        println(worldwrap(test, "test", false))
    printfn("%d", 5, 0)

    var fp = fn(x) x.y
    var p = Point { x = 1, y = 2 }
    p.y = 5
    printfn("point %d,%d", p.x, fp(p))

    var loc = Location {}
    printfn("location %d,%d", loc.line, loc.column)

    var foo = [3, 4]
    printfn("array %d,%d", foo[0], foo[1] + singleton(5)[0])

    dump([1, 2, 3, 4, 5, 6].map(fn (x) x * 4))
    dump([1, 2, 3].append(4))
    iter(append([], "foo"), fn(i,x) println(x))

    printfn("pair %d", first({ first = 1, second = "hey"}), 0)

    dump([1, 2, 3, 4, 5, 6].map(fn (x) x * 4).filter(fn (x) x % 8 == 0))

    printfn("sum %d", [1, 2, 3, 4, 5, 6].reduce(fn (a, b) a + b, 0), 0)

    dump([1, 2, 3, 4, 5, 6].scan(fn (s, x) s + x, 0))

    assert(1 == 1)

    var a = [new 1, new 3]
    dumpp(a)
    dumpp(a)

    0

test()

fn worldwrap(f: fn(string, bool): string, arg0: string, arg1: bool): string
    f(arg0, arg1)