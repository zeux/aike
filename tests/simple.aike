extern fn init()
extern fn println(str: string)
extern fn printfn(str: string, val: int, val: int)

builtin fn sizeof<T>(): int

fn concat<T>(a: [T], b: [T]): [T]
    extern fn aike_concat(a: [T], b: [T], e: int): [T]

    aike_concat(a, b, sizeof.<T>())

fn append<T>(a: [T], e: T): [T]
    concat(a, [e])

struct Pair<T, U>
    first: T
    second: U

struct Point
    x: int
    y: int

struct Location
    line: int = defline()
    column: int = 8

fn defline(): int
    println("defline!")
    4

fn singleton<T>(v: T): [T]
    [v]

fn world(dbg: string, print: bool): string
    if print
        println(dbg)
    "world"

fn iter<T>(data: [T], f: fn(int, T))
    fn helper(data: _, f: _, offset: _)
        if offset < #data
            f(offset, data[offset])
            helper(data, f, offset + 1)

    helper(data, f, 0)

fn dump(data: [int])
    iter(data, fn (i,x) printfn("[%d]: %d", i, x))

fn first<T, U>(p: Pair.<T, U>): T
    p.first

fn main(): int
    init()
    var hello = "Hello, "
    var foo = false
    if foo
        println("")
    else
        fn test(a0: string, a1: bool): string
            "inner"
        var f = fn (a0, a1) a0(a1)
        var g = f(fn(x) x, 1)
        println(worldwrap(fn (a0, a1) a0, "test", false))
        println(worldwrap(fn (a0: string, a1: bool): string "x", "test", false))
        println(worldwrap(world, "test", false))
        println(worldwrap(test, "test", false))
    printfn("%d", 5, 0)

    var fp = fn(x) x.y
    var p = Point { x = 1, y = 2 }
    printfn("point %d,%d", p.x, fp(p))

    var loc = Location {}
    printfn("location %d,%d", loc.line, loc.column)

    var foo = [3, 4]
    printfn("array %d,%d", foo[0], foo[1] + singleton(5)[0])

    dump([1, 2, 3, 4, 5, 6])
    dump(append([1, 2, 3], 4))
    iter(append([], "foo"), fn(i,x) println(x))

    printfn("pair %d", first({ first = 1, second = "hey"}), 0)

    0

fn worldwrap(f: fn(string, bool): string, arg0: string, arg1: bool): string
    f(arg0, arg1)